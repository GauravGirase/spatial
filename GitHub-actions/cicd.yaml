# File: .github/workflows/ci-cd.yaml
name: Enterprise CI/CD Pipeline  # Human-readable name of the workflow

# Trigger the workflow on push or pull request to main/dev branches
on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:          # Allow manual trigger from GitHub UI

# Define environment-wide variables (non-secret)
env:
  APP_NAME: myapp
  DOCKER_REGISTRY: ghcr.io    # GitHub Container Registry
  KUBE_CONTEXT: prod-cluster  # Kubernetes context name
  MAVEN_CACHE_DIR: ~/.m2/repository

jobs:
  # ================================
  # 1️⃣ Build and Test Job
  # ================================
  build-test:
    name: Build & Test
    runs-on: ubuntu-latest      # Managed runner OS

    # Use caching to speed up dependency downloads
    steps:
      - name: Checkout code
        uses: actions/checkout@v3  # Pull repository code

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'maven'             # Automatically cache Maven dependencies

      - name: Cache Maven Dependencies
        uses: actions/cache@v3
        with:
          path: ${{ env.MAVEN_CACHE_DIR }}
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build & Test
        run: mvn clean verify -B       # Clean build and run tests in batch mode

      - name: Upload Test Results
        if: always()                  # Upload even if tests fail
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: target/surefire-reports

      - name: SonarQube Analysis
        if: github.event_name != 'pull_request' # Optional: skip on PRs
        uses: sonarsource/sonarcloud-github-action@v2
        with:
          projectKey: myorg_myapp
          organization: myorg
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}  # Inject secret safely

  # ================================
  # 2️⃣ Docker Build & Push Job
  # ================================
  docker:
    name: Docker Build & Push
    needs: build-test                # Run after build-test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}   # Scoped token, no hardcoding

      - name: Build Docker Image
        run: |
          docker build -t ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${{ github.sha }} .
          docker tag ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${{ github.sha }} ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:latest

      - name: Push Docker Image
        run: |
          docker push ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${{ github.sha }}
          docker push ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:latest

      - name: Save Docker Image Digest
        id: docker_info
        run: echo "DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:latest)" >> $GITHUB_OUTPUT

  # ================================
  # 3️⃣ Deploy to Kubernetes
  # ================================
  deploy:
    name: Deploy to Kubernetes
    needs: docker                     # Run after Docker job
    runs-on: ubuntu-latest
    environment:
      name: production                # Map to protected production environment
      url: https://myapp.example.com
    concurrency:
      group: deploy-${{ github.ref }} # Avoid concurrent deploys on same branch
      cancel-in-progress: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubeconfig
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" > kubeconfig.yaml
          export KUBECONFIG=$(pwd)/kubeconfig.yaml

      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/${{ env.APP_NAME }} ${env.APP_NAME}=${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:${{ github.sha }}
          kubectl rollout status deployment/${{ env.APP_NAME }} -n default

      - name: Notify Deployment Success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "✅ Deployment of ${{ env.APP_NAME }} successful! Version: ${{ github.sha }}"
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

      - name: Notify Deployment Failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "❌ Deployment of ${{ env.APP_NAME }} failed! Check workflow logs."
            }
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
